/*
Navicat MySQL Data Transfer

Source Server         : localhos_3306
Source Server Version : 50554
Source Host           : localhost:3306
Source Database       : blog

Target Server Type    : MYSQL
Target Server Version : 50554
File Encoding         : 65001

Date: 2021-06-21 23:29:42
*/

SET FOREIGN_KEY_CHECKS=0;

-- ----------------------------
-- Table structure for t_blog
-- ----------------------------
DROP TABLE IF EXISTS `t_blog`;
CREATE TABLE `t_blog` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `title` varchar(255) DEFAULT NULL,
  `content` longtext,
  `first_picture` varchar(255) DEFAULT NULL,
  `flag` varchar(255) DEFAULT NULL,
  `views` int(11) DEFAULT NULL,
  `comment_count` int(11) DEFAULT NULL,
  `appreciation` bit(1) NOT NULL,
  `share_statement` bit(1) NOT NULL,
  `commentabled` bit(1) NOT NULL,
  `published` bit(1) NOT NULL,
  `recommend` bit(1) NOT NULL,
  `create_time` datetime DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `type_id` bigint(20) DEFAULT NULL,
  `user_id` bigint(20) DEFAULT NULL,
  `description` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  KEY `type_id` (`type_id`) USING BTREE,
  KEY `user_id` (`user_id`) USING BTREE,
  CONSTRAINT `t_blog_ibfk_1` FOREIGN KEY (`type_id`) REFERENCES `t_type` (`id`),
  CONSTRAINT `t_blog_ibfk_2` FOREIGN KEY (`user_id`) REFERENCES `t_user` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=26 DEFAULT CHARSET=utf8 ROW_FORMAT=COMPACT;

-- ----------------------------
-- Records of t_blog
-- ----------------------------
INSERT INTO `t_blog` VALUES ('1', '初步了解SpringBoot2自动配置原理', '2021-04-30 15:00:31 星期五# 01、了解自动配置原理\r\n## 1、SpringBoot特点\r\n### 1.1、依赖管理\r\n• 父项目做依赖管理\r\n```xml\r\n依赖管理    \r\n<parent>\r\n        <groupId>org.springframework.boot</groupId>\r\n        <artifactId>spring-boot-starter-parent</artifactId>\r\n        <version>2.3.4.RELEASE</version>\r\n</parent>\r\n他的父项目\r\n <parent>\r\n    <groupId>org.springframework.boot</groupId>\r\n    <artifactId>spring-boot-dependencies</artifactId>\r\n    <version>2.3.4.RELEASE</version>\r\n  </parent>\r\n几乎声明了所有开发中常用的依赖的版本号,自动版本仲裁机制\r\n```\r\n• 开发导入starter场景启动器\r\n```xml\r\n1、见到很多 spring-boot-starter-* ： *就某种场景\r\n2、只要引入starter，这个场景的所有常规需要的依赖我们都自动引入\r\n3、SpringBoot所有支持的场景\r\nhttps://docs.spring.io/spring-boot/docs/current/reference/html/\r\n     using-spring-boot.html#using-boot-starter\r\n4、见到的  *-spring-boot-starter： 第三方为我们提供的简化开发的场景启动器。\r\n5、所有场景启动器最底层的依赖\r\n<dependency>\r\n  <groupId>org.springframework.boot</groupId>\r\n  <artifactId>spring-boot-starter</artifactId>\r\n  <version>2.3.4.RELEASE</version>\r\n  <scope>compile</scope>\r\n</dependency>\r\n```\r\n• 无需关注版本号，自动版本仲裁\r\n```xml\r\n1、引入依赖默认都可以不写版本\r\n2、引入非版本仲裁的jar，要写版本号。\r\n```\r\n• 可以修改默认版本号\r\n```xml\r\n1、查看spring-boot-dependencies里面规定当前依赖的版本 用的 key。\r\n2、在当前项目里面重写配置\r\n    <properties>\r\n        <mysql.version>5.1.43</mysql.version>\r\n    </properties>\r\n```\r\n\r\n# 2、容器功能\r\n## 2.1、组件添加\r\n### 1、@Configuration\r\nFull模式与Lite模式\r\n• 最佳实战\r\n• 配置类组件之间无依赖关系用Lite模式加速容器启动过程，减少判断\r\n• 配置类组件之间有依赖关系，方法会被调用得到之前单实例组件，用Full模式\r\n```java\r\n############################@Configuration使用示例#######################################\r\n/**\r\n * 1、配置类里面使用@Bean标注在方法上给容器注册组件，默认也是单实例的\r\n * 2、配置类本身也是组件\r\n * 3、proxyBeanMethods：代理bean的方法(如果不写，默认为true)\r\n *      Full(proxyBeanMethods = true)【保证每个@Bean方法被调用多少次返回的组件都是单实例的】\r\n *      Lite(proxyBeanMethods = false)【每个@Bean方法被调用多少次返回的组件都是新创建的】\r\n *      组件依赖必须使用Full模式默认。其他默认是否Lite模式\r\n */\r\n@Configuration(proxyBeanMethods = false)//告诉SpringBoot这是一个配置类 == 配置文件\r\npublic class MyConfig {\r\n    /**\r\n     * Full:外部无论对配置类中的这个组件注册方法调用多少次获取的都是之前注册容器中的单实例对象\r\n     * @return\r\n     */\r\n    @Bean(\"xiaoming\")\r\n    public Person person01(){\r\n        Person person = new Person(\"小明\",18);\r\n        Pet pet = pet01();\r\n        //person组件依赖了Pet组件\r\n        person.setPet(pet);\r\n        return person;\r\n    }\r\n    \r\n    @Bean//下面2.1.2有解释\r\n    public Pet pet01(){\r\n        return new Pet(\"tom01\");\r\n    }\r\n}\r\n###############################@Configuration测试代码如下#################################\r\n@SpringBootApplication\r\npublic class MainApplication {\r\n    public static void main(String[] args) {\r\n        //1、返回我们IOC容器\r\n        ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args);\r\n        //2、查看容器里面的组件\r\n        String[] names = run.getBeanDefinitionNames();\r\n        for (String name : names){\r\n            System.out.println(name);\r\n        }\r\n        //3、从容器中获取组件\r\n        Person person01 = run.getBean(\"xiaoming\", Person.class);\r\n        System.out.println(person01.getName() + \":\" + person01.getAge() + \"岁\");\r\n        Person person02 = run.getBean(\"xiaoming\", Person.class);\r\n        System.out.println(\"组件：\"+ (person01 == person02));\r\n        //如果@Configuration(proxyBeanMethods = true)代理对象调用方法。SpringBoot总会检查这个组件是否在容器中有。\r\n        //保持组件单实例\r\n        MyConfig bean = run.getBean(MyConfig.class);\r\n        System.out.println(bean);\r\n        Person person1 = bean.person01();\r\n        Person person2 = bean.person01();\r\n        System.out.println(person1 == person2);\r\n        Person xiaoMing = run.getBean(\"xiaoming\", Person.class);\r\n        Pet pet01 = run.getBean(\"pet01\", Pet.class);\r\n        System.out.println(\"用户的宠物：\"+ (xiaoMing.getPet() == pet01));\r\n    }\r\n}\r\n```\r\n### 2、@Bean\r\n```java\r\n@Configuration//告诉SpringBoot这是一个配置类 == 配置文件\r\npublic class MyConfig {\r\n    //如果使用@Bean(\"tom\")则组件的id为tom\r\n    @Bean//给容器中添加组件。以方法名作为组件的id。返回类型就是组件类型。返回的值，就是组件在容器中的实例\r\n    public Pet pet01(){\r\n        return new Pet(\"tom01\");\r\n    }\r\n}\r\n```\r\n### 3、@ComponentScan、@Import\r\n```java\r\n################################@#Import使用示例###########################################\r\n/**\r\n * 4、@Import({User.class, DBHelper.class})\r\n *      给容器中自动创建出这两个类型的组件、默认组件的名字就是全类名\r\n */\r\n@Import({User.class, DBHelper.class})\r\n@Configuration(proxyBeanMethods = false) //告诉SpringBoot这是一个配置类 == 配置文件\r\npublic class MyConfig {\r\n}\r\n##############################@ComponentScan使用示例#######################################\r\n//@SpringBootApplication(scanBasePackages=\"com.bo.boot\")//等于下面三个注解\r\n@SpringBootConfiguration\r\n@EnableAutoConfiguration\r\n@ComponentScan(\"com.bo.boot\")//指定扫描路径,即扫描哪个子包下的组件\r\npublic class MainApplication {\r\n    public static void main(String[] args) {\r\n        ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args);\r\n        //5.获取组件\r\n        String[] beanNamesForType = run.getBeanNamesForType(User.class);\r\n        for (String s : beanNamesForType) {\r\n            System.out.println(s);\r\n        }\r\n    }\r\n}\r\n```\r\n### 4、@Conditional\r\n```java\r\n条件装配：满足Conditional指定的条件，则进行组件注入\r\n###################################测试条件装配#############################################\r\n@Configuration(proxyBeanMethods = false)//告诉SpringBoot这是一个配置类 == 配置文件\r\n@ConditionalOnBean(name = \"xiaoming\")//如果容器中有name = \"xxx\"才创建下面组件\r\n//@ConditionalOnMissingBean(name = \"xiaoming\")//如果容器中没有name = \"xxx\"才创建下面组件\r\npublic class MyConfig {\r\n    @Bean(\"xiaoming\")\r\n    public Person person01(){\r\n        Person person = new Person(\"小明\",18);\r\n        Pet pet = pet01();\r\n        //person组件依赖了Pet组件\r\n        person.setPet(pet);\r\n        return person;\r\n    }\r\n    @Bean\r\n    public Pet pet01(){\r\n        return new Pet(\"tom01\");\r\n    }\r\n}\r\n@SpringBootApplication\r\npublic class MainApplication {\r\n    public static void main(String[] args) {\r\n        ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args);\r\n        boolean xiaoming111 = run.containsBean(\"xiaoming\");\r\n        System.out.println(\"容器中是否有xiaoming组件：\" + xiaoming111);\r\n        boolean pet02 = run.containsBean(\"pet01\");\r\n        System.out.println(\"容器中是否有pet01组件：\" + pet02);\r\n    }\r\n}\r\n```\r\n### 5、@ImportResource\r\n```xml\r\n======================beans.xml=========================\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">\r\n    <bean id=\"haha\" class=\"com.bo.boot.bean.Person\">\r\n        <property name=\"name\" value=\"xiaohei\"></property>\r\n        <property name=\"age\" value=\"18\"></property>\r\n    </bean>\r\n    <bean id=\"hehe\" class=\"com.bo.boot.bean.Pet\">\r\n        <property name=\"name\" value=\"wangcai\"></property>\r\n    </bean>\r\n</beans>\r\n```\r\n```java\r\n@ImportResource(\"classpath:beans.xml\")//导入xxx.xml中的配置文件，解析到容器中\r\npublic class MyConfig {}\r\n======================main下测试=================\r\n        boolean haha = run.containsBean(\"haha\");\r\n        boolean hehe = run.containsBean(\"hehe\");\r\n        System.out.println(\"haha:\"+haha);\r\n        System.out.println(\"hehe:\"+hehe);\r\n```\r\n## 2.2、配置绑定\r\n```yaml\r\nmycar:\r\n    name: BC\r\n  price: 500000\r\n```\r\n### 1、@EnableConfigurationProperties + @ConfigurationProperties\r\n```java\r\n@EnableConfigurationProperties(Car.class)\r\n    //1、开启Car配置绑定功能\r\n    //2、把这个Car这个组件自动注册到容器中\r\npublic class MyConfig {\r\n}\r\n-------------------------------------分割线------------------------------------------------\r\n    \r\n@ConfigurationProperties(prefix = \"mycar\")//配置属性（prefix = \"前缀\"）前缀：这个bean与配置文件中哪个前缀下的所有属性一一绑定\r\npublic class Car {\r\n    private String name;\r\n    private Integer price;\r\n    //此处省略get、set、构造器、toString方法\r\n}\r\n```\r\n### 2、@Component + @ConfigurationProperties\r\n```java\r\n/**\r\n * 只有在容器中的组件，才会拥有SpringBoot提供的强大功能\r\n */\r\n@Component//把组件加到容器中\r\n@ConfigurationProperties(prefix = \"mycar\")//配置属性（prefix = \"前缀\"）前缀：这个bean与配置文件中哪个前缀下的所有属性一一绑定\r\npublic class Car {\r\n    private String name;\r\n    private Integer price;\r\n    //此处省略get、set、构造器、toString方法\r\n}\r\n```\r\n# 3、自动配置原理\r\n## 3.1、最佳实践\r\n- 1.引入场景依赖\r\nhttps://docs.spring.io/spring-boot/docs/current/reference/html/using-spring-boot.html#using-boot-starter\r\n\r\n- 2.查看自动配置了哪些（选做）\r\n• 自己分析，引入场景对应的自动配置一般都生效了\r\n• 配置文件中debug=true开启自动配置报告。Negative（不生效）\\Positive（生效）\r\n- 3.是否需要修改\r\n• 参照文档修改配置项\r\n• https://docs.spring.io/spring-boot/docs/current/reference/html/appendix-application-properties.html#common-application-properties\r\n• 自己分析。xxxxProperties绑定了配置文件的哪些。\r\n• 自定义加入或者替换组件\r\n• @Bean、@Component。。。\r\n• 自定义器  XXXXXCustomizer；\r\n• ......\r\n```yaml\r\n#在配置文件application.yaml中修改配置项\r\nserver:\r\n    port: 8080\r\n```\r\n(注：一般我们常用到的是先导入场景依赖，然后根据需要修改配置文件中的配置项即可)\r\n# 4、开发小技巧\r\n## 4.1、Lombok\r\n简化JavaBean开发\r\n```xml\r\n        <dependency>\r\n            <groupId>org.projectlombok</groupId>\r\n            <artifactId>lombok</artifactId>\r\n        </dependency>\r\n并在idea中搜索安装lombok插件\r\n```\r\n```java\r\n====================================简化JavaBean开发======================================\r\n@Data//自动生成get、set、toString、equals、HashCode方法(包括注解@ToString和@EqualsAndHashCode)\r\n//@ToString   //自动toString方法\r\n//@EqualsAndHashCode   //自动生成equals、HashCode方法\r\n@NoArgsConstructor     //自动生成无参构造器\r\n@AllArgsConstructor    //自动生成有参构造器（全部参数）\r\npublic class Pet {\r\n    private String name;\r\n    \r\n    //如果需要特定的某几个参数的构造器需要自己生成（不能用注解）\r\n}\r\n======================================简化日志开发=========================================\r\n@Slf4j  //相当于注入日志\r\n@RestController//功能等同于两个注解\r\n//@ResponseBody\r\n//@Controller\r\npublic class HelloController {\r\n    @RequestMapping(\"/hello\")\r\n    public String handle01(){\r\n        log.info(\"请求进来了....\");\r\n        return \"Hello,Spring Boot 2! \";\r\n    }\r\n}\r\n```\r\n## 4.2、dev-tools\r\n```xml\r\n        <dependency>\r\n            <groupId>org.springframework.boot</groupId>\r\n            <artifactId>spring-boot-devtools</artifactId>\r\n            <optional>true</optional>\r\n        </dependency>\r\n```\r\n项目或者页面修改以后：Ctrl+F9；(作用是让项目重新编译)\r\n## 4.3、Spring Initailizr（项目初始化向导）\r\n### 1、选择我们需要的开发场景\r\n\r\n### 2、自动依赖引入\r\n### 3、自动创建项目结构\r\n### 4、自动编写好主配置类', 'https://picsum.photos/id/70/810/540', '转载', '49', '0', '', '\0', '', '', '', '2021-04-18 21:38:37', '2021-04-30 15:00:04', '31', '1', '在B站观看atguigu雷老师的教学视频后，结合老师的笔记做简单的总结，让我初步了解SpringBoot2自动配置原理。');
INSERT INTO `t_blog` VALUES ('2', '标2分类是boot', '无', null, '转载', '80', '0', '', '\0', '', '', '\0', '2021-04-19 18:14:02', '2019-02-19 18:14:04', '7', '1', null);
INSERT INTO `t_blog` VALUES ('3', '稀疏数组', '# 1.基本介绍\r\n当一个二维数组中大部分元素为０，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。这样可以有效的减少数组占用的内存空间，加快文件的读写速率。\r\n\r\n\r\n稀疏数组的处理方法是:\r\n1)	记录数组一共有几行几列，有多少个不同的值\r\n2)	把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模\r\n\r\n# 2.代码实现\r\n```java\r\npackage com.bo.sparsearray;\r\n/**\r\n * 稀疏数组\r\n *\r\n * 稀疏数组与二维数组的相互转化方法\r\n * @author Bo\r\n * @create 2021-05-06 13:10\r\n */\r\npublic class SparseArray {\r\n\r\n    public static void main(String[] args) {\r\n        // 创建一个原始的二维数组11*11\r\n        // 0：表示没有棋子，1表示黑子，2表示蓝子\r\n        int chessArray[][] = new int[11][11];\r\n        // 初始化二维数组(没有赋值时默认为0，可省略此步骤)\r\n//        for (int i = 0; i < chessArray.length; i++) {\r\n//            for (int j = 0; j < chessArray[0].length; j++) {\r\n//                chessArray[i][j] = 0;\r\n//            }\r\n//        }\r\n        chessArray[1][2] = 1;\r\n        chessArray[5][6] = 1;\r\n        chessArray[2][4] = 2;\r\n        chessArray[3][4] = 2;\r\n        SparseArray s = new SparseArray();\r\n\r\n        System.out.println(\"原始的二维数组：\");\r\n        s.outArray(chessArray);\r\n\r\n        System.out.println(\"压缩后的稀疏数组：\");\r\n        int[][] sparseArray = s.toSparseArray(chessArray);\r\n        s.outArray(sparseArray);\r\n\r\n        System.out.println(\"还原后的二维数组：\");\r\n        int[][] chessArray1 = s.toChessArray(sparseArray);\r\n        s.outArray(chessArray1);\r\n    }\r\n\r\n\r\n    /**\r\n     * 将二维数组转成稀疏数组通用的方法\r\n     * @param chessArray\r\n     * @return\r\n     */\r\n    public int[][] toSparseArray(int[][] chessArray){\r\n        // 遍历原始的二维数组，得到其中有效值的个数sum\r\n        int sum = 0;\r\n        for (int i = 0; i < chessArray.length; i++) {\r\n            for (int j = 0; j < chessArray[0].length; j++) {\r\n                if (chessArray[i][j] != 0)\r\n                    sum++;\r\n            }\r\n        }\r\n        // 根据二维数组有效值的个数创建稀疏数组，行数为 有效值sum+1 、列数固定为 3\r\n        int sparseArray[][] = new int[sum+1][3];\r\n        // 给稀疏数组的第一行数据赋值，值分别为二维数组的行数、列数、有效值个数\r\n        sparseArray[0][0] = chessArray.length;\r\n        sparseArray[0][1] = chessArray[0].length;\r\n        sparseArray[0][2] = sum;\r\n\r\n        // 遍历二维数组，并取出其有效值的行号列号和值赋给稀疏数组\r\n        int count = 1;  // count 用于记录是第几个有效值\r\n        for (int i = 0; i < chessArray.length; i++) {\r\n            for (int j = 0; j < chessArray[0].length; j++) {\r\n                if (chessArray[i][j] != 0){\r\n                    sparseArray[count][0] = i;\r\n                    sparseArray[count][1] = j;\r\n                    sparseArray[count][2] = chessArray[i][j];\r\n                    count++;\r\n                }\r\n            }\r\n        }\r\n\r\n        return sparseArray;\r\n    }\r\n\r\n\r\n    /**\r\n     * 将稀疏数组转成二维数组通用的方法\r\n     * @param sparseArray\r\n     * @return\r\n     */\r\n    public int[][] toChessArray(int[][] sparseArray){\r\n        // 根据稀疏数组第一行数据(原来存储进去的二维数组行数、列数)\r\n        // 根据获取的行数和列数创建二维数组\r\n        int row = sparseArray[0][0];\r\n        int col = sparseArray[0][1];\r\n        int chessArray[][] = new int[row][col];\r\n        // 初始化二维数组\r\n//        for (int i = 0; i < row; i++) {\r\n//            for (int j = 0; j < col; j++) {\r\n//                chessArray[i][j] = 0;\r\n//            }\r\n//        }\r\n        // 遍历稀疏数组(从第二行开始，遍历次数为稀疏数组的长度-1，即是有效值的个数)，并赋值给二维数组\r\n        for (int i = 1; i < sparseArray.length; i++) {\r\n            int chessRow = sparseArray[i][0];\r\n            int chessCol = sparseArray[i][1];\r\n            int chessValue = sparseArray[i][2];\r\n            chessArray[chessRow][chessCol] = chessValue;\r\n        }\r\n\r\n        return chessArray;\r\n    }\r\n\r\n    /**\r\n     * 二维数组输出的通用方法\r\n     * @param array\r\n     */\r\n    public void outArray(int[][] array){\r\n        for (int[] ints : array) {\r\n            for (int anInt : ints) {\r\n                System.out.print(anInt + \"  \");\r\n            }\r\n            System.out.println();\r\n        }\r\n        System.out.println();\r\n    }\r\n}\r\n```\r\n# 3.应用实例\r\n1)	使用稀疏数组，来保留类似前面的二维数组(棋盘、地图等等)\r\n2)	把稀疏数组存盘，并且可以从新恢复原来的二维数组数\r\n3)	整体思路分析\r\n\r\n', 'https://picsum.photos/id/132/810/540', '原创', '75', '1', '', '', '', '', '', '2021-04-19 18:15:13', '2021-05-08 08:28:04', '32', '1', '稀疏数组，用于某些二维数组的很多值是默认值 0（或者同一个值）时,  此时该二维数组记录了很多没有意义的数据，改用稀疏数组存储更加合适。');
INSERT INTO `t_blog` VALUES ('5', '标题5分类是boot', 'asasas标题fdfdf', null, '转载', '81', '0', '', '', '', '', '', '2021-04-19 21:16:58', '2020-07-05 21:17:01', '1', '1', null);
INSERT INTO `t_blog` VALUES ('6', '算法的时间复杂度和空间复杂度的简介', '# 1.算法的时间复杂度\r\n\r\n### 1.2度量一个程序(算法)执行时间的两种方法\r\n\r\n1) 事后统计的方法\r\n这种方法可行, 但是有两个问题：一是要想对设计的算法的运行性能进行评测，需要实际运行该程序；二是所得时间的统计量依赖于计算机的硬件、软件等环境因素, 这种方式，要在同一台计算机的相同状态下运行，才能比较那个算法速度更快。\r\n2) 事前估算的方法\r\n通过分析某个算法的时间复杂度来判断哪个算法更优.\r\n\r\n### 1.3时间频度\r\n1.基本介绍\r\n时间频度：一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。记为 T(n)。\r\n\r\n对于时间频率 T(n)，有以下三个特点：\r\n**1) 可忽略常数项**\r\n**2) 可忽略低次项**\r\n**3) 可忽略系数**\r\n\r\n结论:\r\n1)	随着 n 值变大，5n^2+7n  和 3n^2 + 2n  ，执行曲线重合,  说明	这种情况下, 5 和 3 可以忽略。\r\n2)	而 n^3+5n 和 6n^3+4n	，执行曲线分离，说明多少次方式关键\r\n\r\n### 1.4时间复杂度\r\n1)	一般情况下，算法中的基本操作语句的重复执行次数是问题规模 n 的某个函数，用 T(n)表示，若有某个辅助函数 f(n)，使得当 n 趋近于无穷大时，T(n) / f(n) 的极限值为不等于零的常数，则称 f(n)是 T(n)的同数量级函数。记作 T(n)=Ｏ( f(n) )，称Ｏ( f(n) ) 为算法的渐进时间复杂度，简称时间复杂度。\r\n2)	T(n) 不同，但时间复杂度可能相同。 如：T(n)=n²+7n+6 与 T(n)=3n²+2n+2 它们的 T(n) 不同，但时间复杂度相同，都为 O(n²)。\r\n3)	计算时间复杂度的方法：\r\n先用常数 1 代替运行时间中的所有加法常数 T(n)=n²+7n+6	=> T(n)=n²+7n+1\r\n然后修改后的运行次数函数中，只保留最高阶项 T(n)=n²+7n+1 => T(n) = n²\r\n最后去除最高阶项的系数 T(n) = n² => T(n) = n² => O(n²)\r\n\r\n### 1.5常见的时间复杂度\r\n1)	常数阶 O(1)\r\n2)	对数阶 O(log2n)\r\n3)	线性阶 O(n)\r\n4)	线性对数阶 O(nlog2n)\r\n5)	平方阶 O(n^2)\r\n6)	立方阶 O(n^3)\r\n7)	k 次方阶 O(n^k)\r\n8)	指数阶 O(2^n)\r\n\r\n说明：\r\n1) 常见的算法时间复杂度由小到大依次为：Ο(1)＜Ο(log2n)＜Ο(n)＜Ο(nlog2n)＜Ο(n2)＜Ο(n3)＜ Ο(nk)  ＜ Ο(2n) ，随着问题规模 n 的不断增大，上述时间复杂度不断增大，算法的执行效率越低\r\n2) 我们应该尽可能避免使用指数阶的算法\r\n\r\n注：O(n³)相当于三层 n 循环，其它的类似\r\n\r\n### 1.6 平均时间复杂度和最坏时间复杂度\r\n1) 平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，该算法的运行时间。\r\n2) 最坏情况下的时间复杂度称最坏时间复杂度。一般讨论的时间复杂度均是最坏情况下的时间复杂度。这样做的原因是：最坏情况下的时间复杂度是算法在任何输入实例上运行时间的界限，这就保证了算法的运行时间不会比最坏情况更长。\r\n3) 平均时间复杂度和最坏时间复杂度是否一致，和算法有关。\r\n\r\n\r\n\r\n# 2.算法的空间复杂度简介\r\n### 2.1基本介绍\r\n1) 类似于时间复杂度的讨论，一个算法的空间复杂度(Space Complexity)定义为该算法所耗费的存储空间，它也是问题规模 n 的函数。\r\n2) 空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度。有的算法需要占用的临时工作单元数与解决问题的规模 n 有关，它随着 n 的增大而增大，当 n 较大时，将占用较多的存储单元，例如快速排序和归并排序算法, 基数排序就属于这种情况\r\n3) 在做算法分析时，主要讨论的是时间复杂度。从用户使用体验上看，更看重的程序执行的速度。一些缓存产品\r\n(redis, memcache)和算法(基数排序)本质就是用空间换时间.\r\n', 'https://picsum.photos/id/139/810/540', '转载', '133', '7', '\0', '', '', '', '', '2021-04-19 21:20:08', '2021-05-13 20:13:23', '32', '1', '关于算法的时间复杂度和空间复杂度的简介');
INSERT INTO `t_blog` VALUES ('12', '晚秋随想', '#### 　　十月，晚秋，天气不是很冷，也不热，天空因为湛蓝显得更高，更明亮。\r\n\r\n　　在季节的交替下，田野开始出现淡淡的黄色，尤其是路边的树叶，黄的可爱。远山却是绿色的，因为山上种的全是苍翠的松树。古城的路边，鲜花依然开得娇艳，小河里的鱼儿和往常一样畅快的游动，它们丝毫没有感觉到冬的气息。从四方街光滑的石板上可以看出这座城的古老，远处悠扬的纳西古乐和现代流行曲混杂在一起。人们喜欢回忆过去，但更喜欢现代文明。有人说丽江商业气息愈来愈浓了，古城越来越多的酒吧说明了这点。昂贵的价钱，换来游客们的笑脸。不过不要羡慕别人，拉着纳西老奶，围着篝火，在广场上尽情的跳，快乐随处可见。在丽江，我们找到的是更多的清幽，舒服的空气，灿烂的阳光。\r\n\r\n#### 　　而晚秋的夜，夜凉如水，比冬少一份沉寂，比夏多几分淡泊。\r\n\r\n　　院子里的玫瑰开了，花香透过窗户轻轻的飘来，像月光一样弥漫在室内。把头伸到窗外，却无意看见一只孤燕从房檐掠过，看它匆匆忙忙的样子，不知道是不是在准备冬天的暖巢?\r\n\r\n　　打开电脑，打开音乐，却是那首忧郁伤感的歌声：“我再等一分钟，或许下一分钟，看到你闪躲的眼，我不会让伤心的泪挂满你的脸。我在等一分钟，或许下一分钟，能够感觉你也心痛，那一年我不会让离别成永远”。\r\n\r\n　　一些淡淡的说不清什么感觉的湿润随着旋律在心底流淌，赶紧关了歌曲，静静的在沙发上呆呆的愣了几分钟。那些远去的东西，如同大学毕业时的欢送会一样，纯真，善良，不想用世俗的烟雨去诬蔑，而脆弱虚伪的心，再也体会不到明朗流畅的曲调了。让心的底版多一些清爽与平静吧。\r\n\r\n　　其实我和很多人一样喜欢在逃避和无法逃避之中循环着，也许是太年轻了，疏狂而轻率的想法总是不堪一击。满以为用成熟去伪装自己的眼神，激情就不再流淌;满以为只要关掉书签，文字就不再对谁开放。“*渐行渐远更生*”。自己掩盖不了自己的思想。“如果你感到不快乐，那么唯一能找到快乐的方法，就是振奋精神，使行动和言词好像已经感觉到快乐的样子”。\r\n\r\n　　**晚秋过后，很多花都要明年才开放了。**“待到山花烂漫时，它在从中笑”。西风过后，便是冰雪，那孤傲的梅花和幽兰将在那个季节开放，赏花的心情是否和今夜一样?明天，当黎明推开黑夜，是不是又将面对满地落花，那些躺了一地惨淡的花色，像极了那些的苍白的笑容，暴露出压抑过的黑夜的哭泣。\r\n\r\n　　或许我无需忧虑，虽然总有秋风会去收集落叶，总有冰雪会去封锁长路，但春天它从来没有错过向花容鸟语发出请柬。就让我们静静地聆听，默默地享受甜蜜的等待吧。**希望有人过了冬天，会更加有朝气。**\r\n\r\n', 'https://picsum.photos/id/112/810/540', '转载', '52', '0', '', '', '', '', '', '2021-04-23 11:24:40', '2021-04-24 23:04:38', '28', '1', '晚秋随想');
INSERT INTO `t_blog` VALUES ('16', '平衡二叉树（ASL）', '# 1. 平衡二叉树(AVL树)\r\n# 1.1 BST的不足\r\n看一个案例(说明二叉排序树可能的问题)\r\n给你一个数列{1,2,3,4,5,6}，要求创建一颗二叉排序树(BST), 并分析问题所在.\r\n此时二叉排序树 BST 存在的问题分析:\r\n1)	左子树全部为空，从形式上看，更像一个单链表.\r\n2)	插入速度没有影响\r\n3)	查询速度明显降低(因为需要依次比较), 不能发挥 BST 的优势，因为每次还需要比较左子树，其查询速度比单链表还慢\r\n4)	解决方案-平衡二叉树(AVL)\r\n\r\n\r\n## 1.2 AVL基本介绍\r\n\r\n1)	平衡二叉树也叫平衡二叉搜索树（Self-balancing binary search tree）又被称为 AVL 树， 可以保证查询效率较高。\r\n2)	具有以下特点：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过 1，并且左右两个子树都是一棵平衡二叉树。平衡二叉树的常用实现方法有红黑树、AVL、替罪羊树、Treap、伸展树等。\r\n3)	举例说明, 看看下面哪些 AVL 树, 为什么?\r\n\r\n## 1.3 代码实现\r\n```java\r\npackage com.bo.avl;\r\n\r\n/**\r\n * 平衡二叉树\r\n *\r\n * @author Bo\r\n * @create 2021-05-23 11:30\r\n */\r\npublic class AVLTreeDemo {\r\n    public static void main(String[] args) {\r\n//        int[] arr = {4, 3, 6, 5, 7, 8};\r\n        int[] arr = {10, 12, 8, 9, 7, 6};\r\n\r\n        AVLTree avlTree = new AVLTree();\r\n        //添加结点\r\n        for (int i = 0; i < arr.length; i++) {\r\n            avlTree.add(new Node(arr[i]));\r\n        }\r\n        System.out.println(\"中序遍历:\");\r\n        avlTree.infixOrder();\r\n\r\n        System.out.println(\"\\n平衡处理~~\");\r\n        System.out.println(\"树的高度 = \" + avlTree.getRoot().height());\r\n        System.out.println(\"树的左子树高度 = \" + avlTree.getRoot().leftHeight());\r\n        System.out.println(\"树的右子树高度 = \" + avlTree.getRoot().rightHeight());\r\n\r\n\r\n    }\r\n}\r\n\r\n//创建平衡二叉树(AVL)\r\nclass AVLTree {\r\n    private Node root;\r\n\r\n    public Node getRoot() {\r\n        return root;\r\n    }\r\n\r\n    //查找要删除的结点\r\n    public Node search(int val) {\r\n        if (root == null) {\r\n            return null;\r\n        } else {\r\n            return root.search(val);\r\n        }\r\n    }\r\n\r\n    //查找要删除的结点的父结点\r\n    public Node searchParent(int val) {\r\n        if (root == null) {\r\n            return null;\r\n        } else {\r\n            return root.searchParent(val);\r\n        }\r\n    }\r\n\r\n    //删除结点\r\n    public boolean deleteNode(int val) {\r\n        if (root == null) {\r\n            return false;\r\n        } else {\r\n            //1.需求先去找到要删除的结点	targetNode\r\n            Node targetNode = search(val);\r\n            //如果没有找到要删除的结点\r\n            if (targetNode == null) {\r\n                return false;\r\n            }\r\n            //如果查找到了要删除的结点，且当前这颗二叉排序树只有一个结点\r\n            if (root.getLeft() == null && root.getRight() == null) {\r\n                root = null;\r\n                return true;\r\n            }\r\n            //去找到 targetNode 的父结点\r\n            Node parentNode = searchParent(val);\r\n\r\n            //情况1 如果要删除的结点是叶子结点\r\n            if (targetNode.getLeft() == null && targetNode.getRight() == null) {\r\n                //判断 targetNode 是父结点的左子结点，还是右子结点\r\n                if (parentNode.getLeft() == targetNode) {       //是左子结点\r\n                    parentNode.setLeft(null);\r\n                } else {                                        //是右子结点\r\n                    parentNode.setRight(null);\r\n                }\r\n                return true;\r\n            }\r\n\r\n            //情况2 如果要删除的结点是只有一颗子树的结点\r\n            if (targetNode.getLeft() != null && targetNode.getRight() == null) {        //targetNode 的左子结点不为空，右子结点为空\r\n                if (parentNode != null) {        //对当前结点的父结点进行判断,如果父结点为空,则此时要删除的结点就是根节点\r\n                    if (parentNode.getLeft() == targetNode) {       //如果此时targetNode 是 parentNode  的左子结点时\r\n                        parentNode.setLeft(targetNode.getLeft());\r\n                    } else {                                        //如果此时targetNode 是 parentNode  的右子结点时\r\n                        parentNode.setRight(targetNode.getLeft());\r\n                    }\r\n                } else {\r\n                    root = targetNode.getLeft();\r\n                }\r\n                return true;\r\n            } else if (targetNode.getLeft() == null && targetNode.getRight() != null) {  //targetNode 的左子结点为空，右子结点不为空\r\n                if (parentNode != null) {\r\n                    if (parentNode.getLeft() == targetNode) {       //类似上面\r\n                        parentNode.setLeft(targetNode.getRight());\r\n                    } else {\r\n                        parentNode.setRight(targetNode.getRight());\r\n                    }\r\n                } else {\r\n                    root = targetNode.getRight();\r\n                }\r\n                return true;\r\n            }\r\n\r\n            //情况3  如果要删除的结点是有两颗子树的节点\r\n            if (targetNode.getRight() != null) {\r\n                //从targetNode的右子结点开始找最小值，并返回最小值且删除最小结点\r\n                //false表示调用getMinNode方法结点是targetNode的右子结点\r\n                int min = targetNode.getRight().getMinNode(targetNode, false);\r\n                targetNode.setVal(min);\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    //添加结点的方法\r\n    public void add(Node node) {\r\n        if (root == null) {\r\n            root = node;        //如果根节点为空则直接让root指向node\r\n        } else {\r\n            root.add(node);     //root不为空，添加新结点\r\n        }\r\n    }\r\n\r\n\r\n    //中序遍历\r\n    public void infixOrder() {\r\n        if (root != null) {\r\n            root.infixOrder();\r\n        } else {\r\n            System.out.println(\"根节点为空，二叉排序树遍历失败！\");\r\n        }\r\n    }\r\n}\r\n\r\n//创建Node结点\r\nclass Node {\r\n\r\n    private int val;\r\n    private Node left;\r\n    private Node right;\r\n\r\n    public Node(int val) {\r\n        this.val = val;\r\n    }\r\n\r\n    public int getVal() {\r\n        return val;\r\n    }\r\n\r\n    public void setVal(int val) {\r\n        this.val = val;\r\n    }\r\n\r\n    public Node getLeft() {\r\n        return left;\r\n    }\r\n\r\n    public void setLeft(Node left) {\r\n        this.left = left;\r\n    }\r\n\r\n    public Node getRight() {\r\n        return right;\r\n    }\r\n\r\n    public void setRight(Node right) {\r\n        this.right = right;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"Node{\" +\r\n                \"val=\" + val +\r\n                \'}\';\r\n    }\r\n\r\n    //添加结点的方法\r\n    //递归的形式添加结点，注意需要满足二叉排序树的要求\r\n    public void add(Node node) {\r\n        if (node == null) {\r\n            return;\r\n        }\r\n        //判断传入的结点值，和当前子树的根结点的值关系\r\n        if (node.val < this.val) {      //添加的结点值小于当前结点值\r\n            //如果当前结点左子结点为null\r\n            if (this.left == null) {\r\n                //直接把新的结点添加到当前结点的左子结点位置\r\n                this.left = node;\r\n            } else {\r\n                //递归左子树添加\r\n                this.left.add(node);\r\n            }\r\n        } else {                         //类似上面\r\n            if (this.right == null) {\r\n                this.right = node;\r\n            } else {\r\n                this.right.add(node);\r\n            }\r\n        }\r\n\r\n        //当添加完一个结点后，如果: (右子树的高度-左子树的高度) > 1 ,  左旋转\r\n        if (this.rightHeight() - this.leftHeight() > 1){\r\n            //如果它的右子树的左子树的高度大于它的右子树的右子树的高度\r\n            if (this.right.leftHeight() > this.right.rightHeight()){\r\n                //先对右子结点进行右旋转\r\n                this.right.rightRotate();\r\n            }\r\n            //对当前结点进行左旋转\r\n            this.leftRotate();\r\n        }\r\n        //当添加完一个结点后，如果 (左子树的高度 - 右子树的高度) > 1, 右旋转\r\n        else if (this.leftHeight() - this.rightHeight() > 1){\r\n            //如果它的左子树的右子树高度大于它的左子树的高度\r\n            if (this.left.rightHeight() > this.left.leftHeight()){\r\n                //先对当前结点的左结点(左子树)->左旋转\r\n                this.left.leftRotate();\r\n            }\r\n            //对当前结点进行右旋转\r\n            this.rightRotate();\r\n        }\r\n    }\r\n\r\n\r\n    //中序遍历\r\n    public void infixOrder() {\r\n        if (this.left != null) {\r\n            this.left.infixOrder();\r\n        }\r\n        System.out.println(this);\r\n        if (this.right != null) {\r\n            this.right.infixOrder();\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * 查找要删除的结点\r\n     *\r\n     * @param val 希望删除的结点的值\r\n     * @return 如果找到则返回该结点，否则返回null\r\n     */\r\n    public Node search(int val) {\r\n        if (this.val == val) {\r\n            return this;\r\n        } else if (val < this.val && this.left != null) {\r\n            return this.left.search(val);\r\n        } else if (val > this.val && this.right != null) {\r\n            return this.right.search(val);\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 查找要删除的结点的父结点\r\n     *\r\n     * @param val 希望删除的结点的值\r\n     * @return 如果找到则返回要删除的结点的父结点，否则返回null\r\n     */\r\n    public Node searchParent(int val) {\r\n        //如果当前结点就是要删除的结点的父结点，就返回\r\n        if (this.left != null && this.left.val == val) {\r\n            return this;\r\n        }\r\n        if (this.right != null && this.right.val == val) {\r\n            return this;\r\n        }\r\n        if (this.left != null && val < this.val) {       //如果查找的值小于当前结点的值，并且当前结点的左子结点不为空\r\n            return this.left.searchParent(val);         //向左子树递归查找\r\n        } else if (this.right != null && val >= this.val) {\r\n            return this.right.searchParent(val);\r\n        } else {\r\n            return null;        //没有找到父结点\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * 找到当前结点的最小子结点，返回最小子结点的val值并删除该结点\r\n     *\r\n     * @param pre  当前结点的父结点\r\n     * @param flag true表示当前结点为父结点的左子结点，反之亦然\r\n     * @return 返回值为当前结点的最小子结点的val\r\n     */\r\n    public int getMinNode(Node pre, boolean flag) {\r\n        if (this.left == null) {\r\n            int minVal = this.val;\r\n            if (flag) {\r\n                pre.left = this.right;\r\n            } else {\r\n                pre.right = this.right;\r\n            }\r\n            return minVal;\r\n        }\r\n        return this.left.getMinNode(this, true);\r\n    }\r\n\r\n\r\n    //返回以该结点为根结点的树的高度\r\n    public int height() {\r\n        int leftHeight = 0;     //先暂定当前结点的左子树高度为0\r\n        int rightHeight = 0;    //先暂定当前结点的右子树高度为0\r\n        if (this.left != null) {     //如果当前结点的左子树不为空\r\n            leftHeight = this.left.height();    //向当前结点的左子树递归获取到当前结点左子树的高度,直到左子结点为空\r\n        }\r\n        if (this.right != null) {     //如果当前结点的右子树不为空\r\n            rightHeight = this.right.height();   //向当前结点的右子树递归获取到当前结点右子树的高度,直到右子结点为空\r\n        }\r\n        //比较当前结点的左子树高度和右子树高度,,得到最高的那个值+1再返回\r\n        // +1是因为要把当前结点所在的层数加上去,所以左子树/右子树高度+1\r\n        return Math.max(leftHeight, rightHeight) + 1;\r\n    }\r\n\r\n    //返回左子树的高度\r\n    public int leftHeight() {\r\n        if (this.left == null) {\r\n            return 0;\r\n        } else {\r\n            return this.left.height();\r\n        }\r\n    }\r\n\r\n    //返回右子树的高度\r\n    public int rightHeight() {\r\n        if (this.right == null) {\r\n            return 0;\r\n        } else {\r\n            return this.right.height();\r\n        }\r\n    }\r\n\r\n    //左旋转\r\n    private void leftRotate(){\r\n        //创建新的结点，以当前根结点的值\r\n        Node newNode = new Node(this.val);\r\n        //把新的结点的左子树设置成当前结点的左子树\r\n        newNode.left = this.left;\r\n        //把新的结点的右子树设置成带你过去结点的右子树的左子树\r\n        newNode.right = this.right.left;\r\n        //把当前结点的值替换成右子结点的值\r\n        this.val = this.right.val;\r\n        //把当前结点的左子树(左子结点)设置成新的结点\r\n        this.left = newNode;\r\n        //把当前结点的右子树设置成当前结点右子树的右子树\r\n        this.right = this.right.right;\r\n    }\r\n\r\n    //右旋转(注释同上)\r\n    private void rightRotate(){\r\n        Node newNode = new Node(this.val);\r\n        newNode.right = this.right;\r\n        newNode.left = this.left.right;\r\n        this.val = this.left.val;\r\n        this.right = newNode;\r\n        this.left = this.left.left;\r\n    }\r\n}\r\n```\r\n', 'https://picsum.photos/id/165/810/540', '原创', '6', '0', '', '', '', '', '', '2021-04-23 22:21:51', '2021-05-23 21:09:50', '32', '1', '关于平衡二叉树（ASL）的概念以及代码的实现');
INSERT INTO `t_blog` VALUES ('18', '标', 'wasdasd', 'https://picsum.photos/id/112/810/540', '转载', '10', '0', '\0', '', '\0', '', '', '2021-04-23 22:38:10', '2021-03-23 22:39:11', '20', '1', null);
INSERT INTO `t_blog` VALUES ('20', '454645654', 'asasas标题fdfdf', 'https://picsum.photos/id/112/810/540', '原创', '9', '0', '', '', '\0', '', '\0', '2021-04-23 22:50:45', '2018-10-24 10:11:07', '26', '1', '54646456456');
INSERT INTO `t_blog` VALUES ('22', '二叉排序树（BST）', '# 1. 二叉排序树\r\n## 1.1 二叉排序树的应用\r\n先看一个需求，如果给你一个数列 (7, 3, 10, 12, 5, 1, 9)，要求能够高效的完成对数据的查询和添加。\r\n解决方案分析：\r\n\r\n(1)使用数组\r\n数组未排序， 优点：直接在数组尾添加，速度快。 缺点：查找速度慢.\r\n数组排序，优点：可以使用二分查找，查找速度快，缺点：为了保证数组有序，在添加新数据时，找到插入位置后，后面的数据需整体移动，速度慢。\r\n\r\n(2)使用链式存储-链表\r\n不管链表是否有序，查找速度都慢，添加数据速度比数组快，不需要数据整体移动。\r\n\r\n(3)最佳解决方案：使用二叉排序树\r\n\r\n## 1.2 二叉排序树介绍\r\n\r\n二叉排序树：BST: (Binary Sort(Search) Tree), 对于二叉排序树的任何一个非叶子节点，要求左子节点的值比当前节点的值小，右子节点的值比当前节点的值大。\r\n特别说明：如果有相同的值，可以将该节点放在左子节点或右子节点\r\n\r\n## 1.3 代码实现\r\n```java\r\npackage com.bo.binarysorttree;\r\n\r\n\r\n/**\r\n * 二叉排序树\r\n *\r\n * @author Bo\r\n * @create 2021-05-22 13:56\r\n */\r\npublic class BinarySortTreeDemo {\r\n    public static void main(String[] args) {\r\n        int[] arr = {7, 3, 10, 12, 5, 1, 9, 2};\r\n        BinarySortTree tree = new BinarySortTree();\r\n        //循环的添加结点到二叉排序树\r\n        for (int value : arr) {\r\n            tree.add(new Node(value));\r\n        }\r\n\r\n        //中序遍历二叉排序树\r\n        System.out.println(\"中序遍历二叉排序树:\");\r\n        tree.infixOrder();\r\n\r\n        boolean b = tree.deleteNode(2);\r\n        tree.deleteNode(5);\r\n        tree.deleteNode(9);\r\n        tree.deleteNode(12);\r\n        tree.deleteNode(7);\r\n        tree.deleteNode(3);\r\n        tree.deleteNode(10);\r\n        tree.deleteNode(1);\r\n//        if (b) {\r\n//            System.out.println(\"删除成功！\");\r\n//        } else {\r\n//            System.out.println(\"删除失败！\");\r\n//        }\r\n        //System.out.println(\"root = \" + tree.getRoot());\r\n        System.out.println(\"删除后的中序遍历二叉排序树:\");\r\n        tree.infixOrder();\r\n\r\n\r\n    }\r\n}\r\n\r\n//创建二叉排序树\r\nclass BinarySortTree {\r\n    private Node root;\r\n\r\n    public Node getRoot() {\r\n        return root;\r\n    }\r\n\r\n    //查找要删除的结点\r\n    public Node search(int val) {\r\n        if (root == null) {\r\n            return null;\r\n        } else {\r\n            return root.search(val);\r\n        }\r\n    }\r\n\r\n    //查找要删除的结点的父结点\r\n    public Node searchParent(int val) {\r\n        if (root == null) {\r\n            return null;\r\n        } else {\r\n            return root.searchParent(val);\r\n        }\r\n    }\r\n\r\n    //删除结点\r\n    public boolean deleteNode(int val) {\r\n        if (root == null) {\r\n            return false;\r\n        } else {\r\n            //1.需求先去找到要删除的结点	targetNode\r\n            Node targetNode = search(val);\r\n            //如果没有找到要删除的结点\r\n            if (targetNode == null) {\r\n                return false;\r\n            }\r\n            //如果查找到了要删除的结点，且当前这颗二叉排序树只有一个结点\r\n            if (root.getLeft() == null && root.getRight() == null) {\r\n                root = null;\r\n                return true;\r\n            }\r\n            //去找到 targetNode 的父结点\r\n            Node parentNode = searchParent(val);\r\n\r\n            //情况1 如果要删除的结点是叶子结点\r\n            if (targetNode.getLeft() == null && targetNode.getRight() == null) {\r\n                //判断 targetNode 是父结点的左子结点，还是右子结点\r\n                if (parentNode.getLeft() == targetNode) {       //是左子结点\r\n                    parentNode.setLeft(null);\r\n                } else {                                        //是右子结点\r\n                    parentNode.setRight(null);\r\n                }\r\n                return true;\r\n            }\r\n\r\n            //情况2 如果要删除的结点是只有一颗子树的结点\r\n            if (targetNode.getLeft() != null && targetNode.getRight() == null) {        //targetNode 的左子结点不为空，右子结点为空\r\n                if (parentNode != null) {        //对当前结点的父结点进行判断,如果父结点为空,则此时要删除的结点就是根节点\r\n                    if (parentNode.getLeft() == targetNode) {       //如果此时targetNode 是 parentNode  的左子结点时\r\n                        parentNode.setLeft(targetNode.getLeft());\r\n                    } else {                                        //如果此时targetNode 是 parentNode  的右子结点时\r\n                        parentNode.setRight(targetNode.getLeft());\r\n                    }\r\n                }else {\r\n                    root = targetNode.getLeft();\r\n                }\r\n                return true;\r\n            } else if (targetNode.getLeft() == null && targetNode.getRight() != null) {  //targetNode 的左子结点为空，右子结点不为空\r\n                if (parentNode != null) {\r\n                    if (parentNode.getLeft() == targetNode) {       //类似上面\r\n                        parentNode.setLeft(targetNode.getRight());\r\n                    } else {\r\n                        parentNode.setRight(targetNode.getRight());\r\n                    }\r\n                }else {\r\n                    root = targetNode.getRight();\r\n                }\r\n                return true;\r\n            }\r\n\r\n            //情况3  如果要删除的结点是有两颗子树的节点\r\n            if (targetNode.getRight() != null) {\r\n                //从targetNode的右子结点开始找最小值，并返回最小值且删除最小结点\r\n                //false表示调用getMinNode方法结点是targetNode的右子结点\r\n                int min = targetNode.getRight().getMinNode(targetNode, false);\r\n                targetNode.setVal(min);\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    //添加结点的方法\r\n    public void add(Node node) {\r\n        if (root == null) {\r\n            root = node;        //如果根节点为空则直接让root指向node\r\n        } else {\r\n            root.add(node);     //root不为空，添加新结点\r\n        }\r\n    }\r\n\r\n\r\n    //中序遍历\r\n    public void infixOrder() {\r\n        if (root != null) {\r\n            root.infixOrder();\r\n        } else {\r\n            System.out.println(\"根节点为空，二叉排序树遍历失败！\");\r\n        }\r\n    }\r\n}\r\n\r\n\r\n//创建Node结点\r\nclass Node {\r\n\r\n    private int val;\r\n    private Node left;\r\n    private Node right;\r\n\r\n    public Node(int val) {\r\n        this.val = val;\r\n    }\r\n\r\n    public int getVal() {\r\n        return val;\r\n    }\r\n\r\n    public void setVal(int val) {\r\n        this.val = val;\r\n    }\r\n\r\n    public Node getLeft() {\r\n        return left;\r\n    }\r\n\r\n    public void setLeft(Node left) {\r\n        this.left = left;\r\n    }\r\n\r\n    public Node getRight() {\r\n        return right;\r\n    }\r\n\r\n    public void setRight(Node right) {\r\n        this.right = right;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"Node{\" +\r\n                \"val=\" + val +\r\n                \'}\';\r\n    }\r\n\r\n    //添加结点的方法\r\n    //递归的形式添加结点，注意需要满足二叉排序树的要求\r\n    public void add(Node node) {\r\n        if (node == null) {\r\n            return;\r\n        }\r\n        //判断传入的结点值，和当前子树的根结点的值关系\r\n        if (node.val < this.val) {      //添加的结点值小于当前结点值\r\n            //如果当前结点左子结点为null\r\n            if (this.left == null) {\r\n                //直接把新的结点添加到当前结点的左子结点位置\r\n                this.left = node;\r\n            } else {\r\n                //递归左子树添加\r\n                this.left.add(node);\r\n            }\r\n        } else {                         //类似上面\r\n            if (this.right == null) {\r\n                this.right = node;\r\n            } else {\r\n                this.right.add(node);\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    //中序遍历\r\n    public void infixOrder() {\r\n        if (this.left != null) {\r\n            this.left.infixOrder();\r\n        }\r\n        System.out.println(this);\r\n        if (this.right != null) {\r\n            this.right.infixOrder();\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * 查找要删除的结点\r\n     *\r\n     * @param val 希望删除的结点的值\r\n     * @return 如果找到则返回该结点，否则返回null\r\n     */\r\n    public Node search(int val) {\r\n        if (this.val == val) {\r\n            return this;\r\n        } else if (val < this.val && this.left != null) {\r\n            return this.left.search(val);\r\n        } else if (val > this.val && this.right != null) {\r\n            return this.right.search(val);\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 查找要删除的结点的父结点\r\n     *\r\n     * @param val 希望删除的结点的值\r\n     * @return 如果找到则返回要删除的结点的父结点，否则返回null\r\n     */\r\n    public Node searchParent(int val) {\r\n        //如果当前结点就是要删除的结点的父结点，就返回\r\n        if (this.left != null && this.left.val == val) {\r\n            return this;\r\n        }\r\n        if (this.right != null && this.right.val == val) {\r\n            return this;\r\n        }\r\n        if (this.left != null && val < this.val) {       //如果查找的值小于当前结点的值，并且当前结点的左子结点不为空\r\n            return this.left.searchParent(val);         //向左子树递归查找\r\n        } else if (this.right != null && val >= this.val) {\r\n            return this.right.searchParent(val);\r\n        } else {\r\n            return null;        //没有找到父结点\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * 找到当前结点的最小子结点，返回最小子结点的val值并删除该结点\r\n     *\r\n     * @param pre  当前结点的父结点\r\n     * @param flag true表示当前结点为父结点的左子结点，反之亦然\r\n     * @return 返回值为当前结点的最小子结点的val\r\n     */\r\n    public int getMinNode(Node pre, boolean flag) {\r\n        if (this.left == null) {\r\n            int minVal = this.val;\r\n            if (flag) {\r\n                pre.left = this.right;\r\n            } else {\r\n                pre.right = this.right;\r\n            }\r\n            return minVal;\r\n        }\r\n        return this.left.getMinNode(this, true);\r\n    }\r\n}\r\n\r\n```', 'https://picsum.photos/id/178/810/540', '原创', '25', '0', '', '', '', '', '', '2021-04-24 10:14:20', '2021-05-23 21:16:32', '32', '1', '关于二叉排序树（BST）的概念以及代码的实现');
INSERT INTO `t_blog` VALUES ('23', ' 关于SpringBoot2.4中JUnit5的简单使用', '# 1、JUnit5 的变化\r\n**Spring Boot 2.2.0 版本开始引入 JUnit 5 作为单元测试默认库**\r\n```xml\r\n<dependency>\r\n  <groupId>org.springframework.boot</groupId>\r\n  <artifactId>spring-boot-starter-test</artifactId>\r\n  <scope>test</scope>\r\n</dependency>\r\n```\r\n现在版本：\r\n```java\r\n@SpringBootTest\r\nclass Boot05WebAdminApplicationTests {\r\n\r\n    @Test\r\n    void contextLoads() {\r\n    }\r\n}\r\n```\r\n以前：\r\n@SpringBootTest + @RunWith(SpringTest.class)\r\n\r\nSpringBoot整合Junit以后。\r\n- 编写测试方法：@Test标注（注意需要使用junit5版本的注解）\r\n- Junit类具有Spring的功能，@Autowired、比如 @Transactional 标注测试方法，测试完成后自动回滚\r\n\r\n# 2、JUnit5常用注解\r\nJUnit5的注解与JUnit4的注解有所变化\r\nhttps://junit.org/junit5/docs/current/user-guide/#writing-tests-annotations\r\n- @Test :表示方法是测试方法。但是与JUnit4的@Test不同，他的职责非常单一不能声明任何属性，拓展的测试将会由Jupiter提供额外测试\r\n- **@ParameterizedTest** :表示方法是参数化测试，下方会有详细介绍\r\n- **@RepeatedTest** :表示方法可重复执行，下方会有详细介绍\r\n- **@DisplayName** :为测试类或者测试方法设置展示名称\r\n- **@BeforeEach** :表示在每个单元测试之前执行\r\n- **@AfterEach** :表示在每个单元测试之后执行\r\n- **@BeforeAll** :表示在所有单元测试之前执行\r\n- **@AfterAll** :表示在所有单元测试之后执行\r\n- **@Tag** :表示单元测试类别，类似于JUnit4中的@Categories\r\n- **@Disabled** :表示测试类或测试方法不执行，类似于JUnit4中的@Ignore\r\n- **@Timeout** :表示测试方法运行如果超过了指定时间将会返回错误\r\n- **@ExtendWith** :为测试类或测试方法提供扩展类引用\r\n\r\n```java\r\nimport org.junit.jupiter.api.Test; //注意这里使用的是jupiter的Test注解！！\r\n\r\n//@SpringBootTest   //如果不加上@SpringBootTest将不能使用springboot容器中的功能\r\n@DisplayName(\"Junit5测试\")\r\npublic class Junit5Test1 {\r\n\r\n	@DisplayName(\"单元测试1\")\r\n    @Test\r\n    void test1(){\r\n        System.out.println(1);\r\n    }\r\n\r\n    @BeforeEach\r\n    void beforeEach(){\r\n        System.out.println(\"一个单元测试开始了...\");\r\n    }\r\n\r\n    @AfterEach\r\n    void afterEach(){\r\n        System.out.println(\"一个单元测试结束了...\");\r\n    }\r\n\r\n    @Disabled\r\n    @Test\r\n    void test2(){\r\n        System.out.println(2);\r\n    }\r\n\r\n    @BeforeAll\r\n    static void beforeAll(){\r\n        System.out.println(\"全部测试要开始了...\");\r\n    }\r\n\r\n    @AfterAll\r\n    static void afterAll(){\r\n        System.out.println(\"全部测试要结束了...\");\r\n    }\r\n\r\n    @RepeatedTest(5)\r\n    @Test\r\n    void test3(){\r\n        System.out.println(3);\r\n    }\r\n\r\n    @Timeout(value = 500,unit = TimeUnit.MILLISECONDS)\r\n    @Test\r\n    void test4() throws InterruptedException {\r\n        Thread.sleep(600);\r\n    }\r\n}\r\n```\r\n# 3、断言（assertions）\r\n断言（assertions）是测试方法中的核心部分，用来对测试需要满足的条件进行验证。**这些断言方法都是 org.junit.jupiter.api.Assertions 的静态方法**。JUnit 5 内置的断言可以分成如下几个类别：\r\n**检查业务逻辑返回的数据是否合理。**\r\n**所有的测试运行结束以后，会有一个详细的测试报告；**\r\n*（注：如果前面断言失败，后面的代码都不会执行）*\r\n## 3.1、简单断言\r\n用来对单个值进行简单的验证。如：\r\n\r\n方法 说明\r\nassertEquals :判断两个对象或两个原始类型是否相等\r\nassertNotEquals :判断两个对象或两个原始类型是否不相等\r\nassertSame :判断两个对象引用是否指向同一个对象\r\nassertNotSame :判断两个对象引用是否指向不同的对象\r\nassertTrue :判断给定的布尔值是否为 true\r\nassertFalse :判断给定的布尔值是否为 false\r\nassertNull :判断给定的对象引用是否为 null\r\nassertNotNull :判断给定的对象引用是否不为 null\r\n\r\n```java\r\n@DisplayName(\"Junit5测试\")\r\npublic class Junit5Test2 {\r\n\r\n    @Test\r\n    @DisplayName(\"简单断言测试\")\r\n    void testAssertEquals(){\r\n        //第一个为期待的值，第二个为真实的值，第三个为断言成功出现的提示语(可用可不用)\r\n//        Assertions.assertEquals(5,add(2,3),\"计算出现异常\");\r\n        assertEquals(5,add(3,3),\"计算出现异常\");\r\n    }\r\n\r\n    int add(int i,int j){\r\n        return i+j;\r\n    }\r\n}\r\n```\r\n## 3.2、数组断言\r\n通过 assertArrayEquals 方法来判断两个对象或原始类型的数组是否相等\r\n```java\r\n    @Test\r\n    @DisplayName(\"数组断言测试\")\r\n    void testAssertArrayEquals(){\r\n        assertArrayEquals(new int[]{2,3},new int[]{1,3});\r\n    }\r\n```\r\n## 3.3、组合断言\r\nassertAll 方法接受多个 org.junit.jupiter.api.Executable 函数式接口的实例作为要验证的断言，可以通过 lambda 表达式很容易的提供这些断言\r\n```java\r\n    @Test\r\n    @DisplayName(\"组合断言测试\")\r\n    void testAssertAll(){\r\n        //assertAll中第一个参数为string字符串，用来给组合断言分组命名(可用可不用)\r\n        assertAll(\"第一组\",\r\n                ()->assertEquals(1,1),\r\n                ()->assertSame(new Object(),new Object())\r\n        );\r\n    }\r\n```\r\n## 3.4、异常断言\r\n在JUnit4时期，想要测试方法的异常情况时，需要用@Rule注解的ExpectedException变量还是比较麻烦的。而JUnit5提供了一种新的断言方式**Assertions.assertThrows()** ,配合函数式编程就可以进行使用。\r\n```java\r\n    @Test\r\n    @DisplayName(\"异常断言测试\")\r\n    public void testException(){\r\n        assertThrows(ArithmeticException.class,()->{\r\n            int i = 10 / 2 ;\r\n        },\"业务逻辑居然正常运行\");\r\n    }\r\n```\r\n## 3.5、超时断言\r\nJunit5还提供了Assertions.assertTimeout() 为测试方法设置了超时时间\r\n```java\r\n    @Test\r\n    @DisplayName(\"超时断言测试\")\r\n    public void timeoutTest() {\r\n        //如果测试方法时间超过1s将会异常\r\n        assertTimeout(Duration.ofMillis(1000), () -> Thread.sleep(500));\r\n    }\r\n```\r\n## 3.6、快速失败\r\n通过 fail 方法直接使得测试失败\r\n```java\r\n    @Test\r\n    @DisplayName(\"快速失败断言测试\")\r\n    public void testFail(){\r\n        System.out.println(1);\r\n        if (2 == 2){\r\n            fail(\"快速失败\");\r\n        }\r\n        System.out.println(2);\r\n    }\r\n```\r\n\r\n# 4、前置条件（assumptions）\r\nJUnit 5 中的前置条件（assumptions【假设】）类似于断言，不同之处在于不满足的断言会使得测试方法失败，而不满足的前置条件只会使得测试方法的执行终止。前置条件可以看成是测试方法执行的前提，当该前提不满足时，就没有继续执行的必要。\r\n```java\r\n    @Test\r\n    @DisplayName(\"前置条件\")\r\n    public void testAssumeTrue(){\r\n        //如果失败则不会报错，后面代码也不会执行，相当于注解@Disabled跳过\r\n        Assumptions.assumeTrue(false,\"结果不是true\");   \r\n        System.out.println(\"11111\");\r\n    }\r\n```\r\nassumeTrue 和 assumFalse 确保给定的条件为 true 或 false，不满足条件会使得测试执行终止。assumingThat 的参数是表示条件的布尔值和对应的 Executable 接口的实现对象。只有条件满足时，Executable 对象才会被执行；当条件不满足时，测试执行并不会终止。\r\n# 5、嵌套测试\r\nJUnit 5 可以通过 Java 中的内部类和@Nested 注解实现嵌套测试，从而可以更好的把相关的测试方法组织在一起。在内部类中可以使用@BeforeEach 和@AfterEach 注解，而且嵌套的层次没有限制。\r\n```java\r\n@DisplayName(\"嵌套测试\")\r\nclass TestingAStackDemo {\r\n\r\n    Stack<Object> stack;\r\n\r\n    @Test\r\n    @DisplayName(\"new Stack()\")\r\n    void isInstantiatedWithNew() {\r\n        new Stack<>();\r\n        //嵌套循环情况下，外层的Test不能驱动内层的Before(After)Each/All之类的方法提前/之后运行\r\n        assertNull(stack);\r\n    }\r\n\r\n    @Nested     //@Nested当前内层为嵌套测试\r\n    @DisplayName(\"when new\")\r\n    class WhenNew {\r\n\r\n        @BeforeEach\r\n        void createNewStack() {\r\n            stack = new Stack<>();\r\n        }\r\n\r\n        @Test\r\n        @DisplayName(\"is empty\")\r\n        void isEmpty() {\r\n            assertTrue(stack.isEmpty());\r\n        }\r\n\r\n        @Test\r\n        @DisplayName(\"throws EmptyStackException when popped\")\r\n        void throwsExceptionWhenPopped() {\r\n            assertThrows(EmptyStackException.class, stack::pop);\r\n        }\r\n\r\n        @Test\r\n        @DisplayName(\"throws EmptyStackException when peeked\")\r\n        void throwsExceptionWhenPeeked() {\r\n            assertThrows(EmptyStackException.class, stack::peek);\r\n        }\r\n\r\n        @Nested\r\n        @DisplayName(\"after pushing an element\")\r\n        class AfterPushing {\r\n\r\n            String anElement = \"an element\";\r\n\r\n            @BeforeEach\r\n            void pushAnElement() {\r\n                stack.push(anElement);\r\n                //内层的Test可以驱动内层的Before(After)Each/All之类的方法提前/之后运行\r\n            }\r\n\r\n            @Test\r\n            @DisplayName(\"it is no longer empty\")\r\n            void isNotEmpty() {\r\n                assertFalse(stack.isEmpty());\r\n            }\r\n\r\n            @Test\r\n            @DisplayName(\"returns the element when popped and is empty\")\r\n            void returnElementWhenPopped() {\r\n                assertEquals(anElement, stack.pop());\r\n                assertTrue(stack.isEmpty());\r\n            }\r\n\r\n            @Test\r\n            @DisplayName(\"returns the element when peeked but remains not empty\")\r\n            void returnElementWhenPeeked() {\r\n                assertEquals(anElement, stack.peek());\r\n                assertFalse(stack.isEmpty());\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n# 6、参数化测试\r\n参数化测试是JUnit5很重要的一个新特性，它使得用不同的参数多次运行测试成为了可能，也为我们的单元测试带来许多便利。\r\n\r\n**利用@ValueSource等注解**，指定入参，我们将可以使用不同的参数进行多次单元测试，而不需要每新增一个参数就新增一个单元测试，省去了很多冗余代码。\r\n\r\n**@ValueSource**: 为参数化测试指定入参来源，支持八大基础类以及String类型,Class类型\r\n**@NullSource**: 表示为参数化测试提供一个null的入参\r\n**@EnumSource**: 表示为参数化测试提供一个枚举入参\r\n**@CsvFileSource**：表示读取指定CSV文件内容作为参数化测试入参\r\n**@MethodSource**：表示读取指定方法的返回值作为参数化测试入参(注意方法返回需要是一个流)\r\n\r\n当然如果参数化测试仅仅只能做到指定普通的入参还达不到让我觉得惊艳的地步。让我真正感到他的强大之处的地方在于他可以支持外部的各类入参。如:CSV,YML,JSON 文件甚至方法的返回值也可以作为入参。只需要去实现**ArgumentsProvide**r接口，任何外部文件都可以作为它的入参。\r\n```java\r\n@DisplayName(\"参数化测试\")\r\nclass Junit5Test3 {\r\n\r\n    @ParameterizedTest\r\n    @DisplayName(\"参数测试1\")\r\n    @ValueSource(ints = {1,2,3,4,5})\r\n    public void test1(int i){\r\n        System.out.println(i);\r\n    }\r\n\r\n    @ParameterizedTest\r\n    @DisplayName(\"参数测试2\")\r\n    @MethodSource(\"method\")\r\n    public void test2(String fruits){\r\n        System.out.println(fruits);\r\n    }\r\n\r\n    static Stream<String> method() {\r\n        return Stream.of(\"apple\", \"banana\",\"watermelon\");\r\n    }\r\n}\r\n```\r\n# 7、迁移指南（可略）\r\n在进行迁移的时候需要注意如下的变化：\r\n- 注解在 org.junit.jupiter.api 包中，断言在 org.junit.jupiter.api.Assertions 类中，前置条件在 org.junit.jupiter.api.Assumptions 类中。\r\n- 把@Before 和@After 替换成@BeforeEach 和@AfterEach。\r\n- 把@BeforeClass 和@AfterClass 替换成@BeforeAll 和@AfterAll。\r\n- 把@Ignore 替换成@Disabled。\r\n- 把@Category 替换成@Tag。\r\n- 把@RunWith、@Rule 和@ClassRule 替换成@ExtendWith。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n', 'https://picsum.photos/id/2/810/540', '转载', '49', '0', '', '\0', '', '', '', '2021-04-27 19:20:12', '2021-04-30 14:57:52', '31', '1', ' 一些关于SpringBoot2.4中JUnit5的简单使用，笔记参考于atguigu的雷老师');
INSERT INTO `t_blog` VALUES ('24', 'JDBC的描述和获取数据库的连接', '## 第1章：JDBC概述\r\n\r\n### 1.1 数据的持久化\r\n\r\n- 持久化(persistence)：**把数据保存到可掉电式存储设备中以供之后使用**。大多数情况下，特别是企业级应用，**数据持久化意味着将内存中的数据保存到硬盘**上加以”固化”**，而持久化的实现过程大多通过各种关系数据库来完成**。\r\n\r\n- 持久化的主要应用是将内存中的数据存储在关系型数据库中，当然也可以存储在磁盘文件、XML数据文件中。\r\n\r\n  ![1566741430592](尚硅谷_宋红康_JDBC.assets/1566741430592.png) \r\n\r\n### 1.2 Java中的数据存储技术\r\n\r\n- 在Java中，数据库存取技术可分为如下几类：\r\n  - **JDBC**直接访问数据库\r\n  - JDO (Java Data Object )技术\r\n\r\n  - **第三方O/R工具**，如Hibernate, Mybatis 等\r\n\r\n- JDBC是java访问数据库的基石，JDO、Hibernate、MyBatis等只是更好的封装了JDBC。\r\n\r\n### 1.3 JDBC介绍\r\n\r\n- JDBC(Java Database Connectivity)是一个**独立于特定数据库管理系统、通用的SQL数据库存取和操作的公共接口**（一组API），定义了用来访问数据库的标准Java类库，（**java.sql,javax.sql**）使用这些类库可以以一种**标准**的方法、方便地访问数据库资源。\r\n- JDBC为访问不同的数据库提供了一种**统一的途径**，为开发者屏蔽了一些细节问题。\r\n- JDBC的目标是使Java程序员使用JDBC可以连接任何**提供了JDBC驱动程序**的数据库系统，这样就使得程序员无需对特定的数据库系统的特点有过多的了解，从而大大简化和加快了开发过程。\r\n- 如果没有JDBC，那么Java程序访问数据库时是这样的：\r\n\r\n![1555575760234](尚硅谷_宋红康_JDBC.assets/1555575760234.png)\r\n\r\n***\r\n\r\n- 有了JDBC，Java程序访问数据库时是这样的：\r\n\r\n\r\n![1555575981203](尚硅谷_宋红康_JDBC.assets/1555575981203.png)\r\n\r\n***\r\n\r\n- 总结如下：\r\n\r\n![1566741692804](尚硅谷_宋红康_JDBC.assets/1566741692804.png)\r\n\r\n### 1.4 JDBC体系结构\r\n\r\n- JDBC接口（API）包括两个层次：\r\n  - **面向应用的API**：Java API，抽象接口，供应用程序开发人员使用（连接数据库，执行SQL语句，获得结果）。\r\n  - **面向数据库的API**：Java Driver API，供开发商开发数据库驱动程序用。\r\n\r\n> **JDBC是sun公司提供一套用于数据库操作的接口，java程序员只需要面向这套接口编程即可。**\r\n>\r\n> **不同的数据库厂商，需要针对这套接口，提供不同实现。不同的实现的集合，即为不同数据库的驱动。																————面向接口编程**\r\n\r\n### 1.5 JDBC程序编写步骤\r\n\r\n![1565969323908](尚硅谷_宋红康_JDBC.assets/1565969323908.png)\r\n\r\n> 补充：ODBC(**Open Database Connectivity**，开放式数据库连接)，是微软在Windows平台下推出的。使用者在程序中只需要调用ODBC API，由 ODBC 驱动程序将调用转换成为对特定的数据库的调用请求。\r\n\r\n## 第2章：获取数据库连接\r\n\r\n### 2.1 要素一：Driver接口实现类\r\n\r\n#### 2.1.1 Driver接口介绍\r\n\r\n- java.sql.Driver 接口是所有 JDBC 驱动程序需要实现的接口。这个接口是提供给数据库厂商使用的，不同数据库厂商提供不同的实现。\r\n\r\n- 在程序中不需要直接去访问实现了 Driver 接口的类，而是由驱动程序管理器类(java.sql.DriverManager)去调用这些Driver实现。\r\n  - Oracle的驱动：**oracle.jdbc.driver.OracleDriver**\r\n  - mySql的驱动： **com.mysql.jdbc.Driver**\r\n\r\n![1555576157618](尚硅谷_宋红康_JDBC.assets/1555576157618.png)\r\n\r\n![1555576170074](尚硅谷_宋红康_JDBC.assets/1555576170074.png)\r\n\r\n- 将上述jar包拷贝到Java工程的一个目录中，习惯上新建一个lib文件夹。\r\n\r\n ![1566134718955](尚硅谷_宋红康_JDBC.assets/1566134718955.png)\r\n\r\n在驱动jar上右键-->Build Path-->Add to Build Path\r\n\r\n ![1566134781682](尚硅谷_宋红康_JDBC.assets/1566134781682.png)\r\n\r\n注意：如果是Dynamic Web Project（动态的web项目）话，则是把驱动jar放到WebContent（有的开发工具叫WebRoot）目录中的WEB-INF目录中的lib目录下即可\r\n\r\n ![1566135290460](尚硅谷_宋红康_JDBC.assets/1566135290460.png)\r\n\r\n#### 2.1.2 加载与注册JDBC驱动\r\n\r\n- 加载驱动：加载 JDBC 驱动需调用 Class 类的静态方法 forName()，向其传递要加载的 JDBC 驱动的类名\r\n\r\n  - **Class.forName(“com.mysql.jdbc.Driver”);**\r\n\r\n- 注册驱动：DriverManager 类是驱动程序管理器类，负责管理驱动程序\r\n\r\n  - **使用DriverManager.registerDriver(com.mysql.jdbc.Driver)来注册驱动**\r\n\r\n  - 通常不用显式调用 DriverManager 类的 registerDriver() 方法来注册驱动程序类的实例，因为 Driver 接口的驱动程序类**都**包含了静态代码块，在这个静态代码块中，会调用 DriverManager.registerDriver() 方法来注册自身的一个实例。下图是MySQL的Driver实现类的源码：\r\n\r\n    ![1566136831283](尚硅谷_宋红康_JDBC.assets/1566136831283.png)\r\n\r\n### 2.2 要素二：URL\r\n\r\n- JDBC URL 用于标识一个被注册的驱动程序，驱动程序管理器通过这个 URL 选择正确的驱动程序，从而建立到数据库的连接。\r\n\r\n- JDBC URL的标准由三部分组成，各部分间用冒号分隔。 \r\n\r\n  - **jdbc:子协议:子名称**\r\n  - **协议**：JDBC URL中的协议总是jdbc \r\n  - **子协议**：子协议用于标识一个数据库驱动程序\r\n  - **子名称**：一种标识数据库的方法。子名称可以依不同的子协议而变化，用子名称的目的是为了**定位数据库**提供足够的信息。包含**主机名**(对应服务端的ip地址)**，端口号，数据库名**\r\n\r\n- 举例：\r\n\r\n  ![1555576477107](尚硅谷_宋红康_JDBC.assets/1555576477107.png)\r\n\r\n- **几种常用数据库的 JDBC URL**\r\n\r\n  - MySQL的连接URL编写方式：\r\n\r\n    - jdbc:mysql://主机名称:mysql服务端口号/数据库名称?参数=值&参数=值\r\n    - jdbc:mysql://localhost:3306/atguigu\r\n    - jdbc:mysql://localhost:3306/atguigu**?useUnicode=true&characterEncoding=utf8**（如果JDBC程序与服务器端的字符集不一致，会导致乱码，那么可以通过参数指定服务器端的字符集）\r\n    - jdbc:mysql://localhost:3306/atguigu?user=root&password=123456\r\n\r\n  - Oracle 9i的连接URL编写方式：\r\n\r\n    - jdbc:oracle:thin:@主机名称:oracle服务端口号:数据库名称\r\n    - jdbc:oracle:thin:@localhost:1521:atguigu\r\n\r\n  - SQLServer的连接URL编写方式：\r\n\r\n    - jdbc:sqlserver://主机名称:sqlserver服务端口号:DatabaseName=数据库名称\r\n\r\n    - jdbc:sqlserver://localhost:1433:DatabaseName=atguigu\r\n\r\n### 2.3 要素三：用户名和密码\r\n\r\n- user,password可以用“属性名=属性值”方式告诉数据库\r\n- 可以调用 DriverManager 类的 getConnection() 方法建立到数据库的连接\r\n\r\n### 2.4 数据库连接方式举例\r\n\r\n#### 2.4.1 连接方式一\r\n\r\n```java\r\n	@Test\r\n    public void testConnection1() {\r\n        try {\r\n            //1.提供java.sql.Driver接口实现类的对象\r\n            Driver driver = null;\r\n            driver = new com.mysql.jdbc.Driver();\r\n\r\n            //2.提供url，指明具体操作的数据\r\n            String url = \"jdbc:mysql://localhost:3306/test\";\r\n\r\n            //3.提供Properties的对象，指明用户名和密码\r\n            Properties info = new Properties();\r\n            info.setProperty(\"user\", \"root\");\r\n            info.setProperty(\"password\", \"abc123\");\r\n\r\n            //4.调用driver的connect()，获取连接\r\n            Connection conn = driver.connect(url, info);\r\n            System.out.println(conn);\r\n        } catch (SQLException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n```\r\n\r\n> 说明：上述代码中显式出现了第三方数据库的API\r\n\r\n#### 2.4.2 连接方式二\r\n\r\n```java\r\n	@Test\r\n    public void testConnection2() {\r\n        try {\r\n            //1.实例化Driver\r\n            String className = \"com.mysql.jdbc.Driver\";\r\n            Class clazz = Class.forName(className);\r\n            Driver driver = (Driver) clazz.newInstance();\r\n\r\n            //2.提供url，指明具体操作的数据\r\n            String url = \"jdbc:mysql://localhost:3306/test\";\r\n\r\n            //3.提供Properties的对象，指明用户名和密码\r\n            Properties info = new Properties();\r\n            info.setProperty(\"user\", \"root\");\r\n            info.setProperty(\"password\", \"abc123\");\r\n\r\n            //4.调用driver的connect()，获取连接\r\n            Connection conn = driver.connect(url, info);\r\n            System.out.println(conn);\r\n\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n```\r\n\r\n> 说明：相较于方式一，这里使用反射实例化Driver，不在代码中体现第三方数据库的API。体现了面向接口编程思想。\r\n\r\n#### 2.4.3 连接方式三\r\n\r\n```java\r\n	@Test\r\n    public void testConnection3() {\r\n        try {\r\n            //1.数据库连接的4个基本要素：\r\n            String url = \"jdbc:mysql://localhost:3306/test\";\r\n            String user = \"root\";\r\n            String password = \"abc123\";\r\n            String driverName = \"com.mysql.jdbc.Driver\";\r\n\r\n            //2.实例化Driver\r\n            Class clazz = Class.forName(driverName);\r\n            Driver driver = (Driver) clazz.newInstance();\r\n            //3.注册驱动\r\n            DriverManager.registerDriver(driver);\r\n            //4.获取连接\r\n            Connection conn = DriverManager.getConnection(url, user, password);\r\n            System.out.println(conn);\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n        }\r\n\r\n    }\r\n```\r\n\r\n> 说明：使用DriverManager实现数据库的连接。体会获取连接必要的4个基本要素。\r\n\r\n#### 2.4.4 连接方式四\r\n\r\n```java\r\n	@Test\r\n    public void testConnection4() {\r\n        try {\r\n            //1.数据库连接的4个基本要素：\r\n            String url = \"jdbc:mysql://localhost:3306/test\";\r\n            String user = \"root\";\r\n            String password = \"abc123\";\r\n            String driverName = \"com.mysql.jdbc.Driver\";\r\n\r\n            //2.加载驱动 （①实例化Driver ②注册驱动）\r\n            Class.forName(driverName);\r\n\r\n\r\n            //Driver driver = (Driver) clazz.newInstance();\r\n            //3.注册驱动\r\n            //DriverManager.registerDriver(driver);\r\n            /*\r\n            可以注释掉上述代码的原因，是因为在mysql的Driver类中声明有：\r\n            static {\r\n                try {\r\n                    DriverManager.registerDriver(new Driver());\r\n                } catch (SQLException var1) {\r\n                    throw new RuntimeException(\"Can\'t register driver!\");\r\n                }\r\n            }\r\n\r\n             */\r\n\r\n\r\n            //3.获取连接\r\n            Connection conn = DriverManager.getConnection(url, user, password);\r\n            System.out.println(conn);\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n        }\r\n\r\n    }\r\n```\r\n\r\n> 说明：不必显式的注册驱动了。因为在DriverManager的源码中已经存在静态代码块，实现了驱动的注册。\r\n\r\n#### 2.4.5 连接方式五(最终版)\r\n\r\n```java\r\n	@Test\r\n    public  void testConnection5() throws Exception {\r\n    	//1.加载配置文件\r\n        InputStream is = ConnectionTest.class.getClassLoader().getResourceAsStream(\"jdbc.properties\");\r\n        Properties pros = new Properties();\r\n        pros.load(is);\r\n        \r\n        //2.读取配置信息\r\n        String user = pros.getProperty(\"user\");\r\n        String password = pros.getProperty(\"password\");\r\n        String url = pros.getProperty(\"url\");\r\n        String driverClass = pros.getProperty(\"driverClass\");\r\n\r\n        //3.加载驱动\r\n        Class.forName(driverClass);\r\n\r\n        //4.获取连接\r\n        Connection conn = DriverManager.getConnection(url,user,password);\r\n        System.out.println(conn);\r\n\r\n    }\r\n```\r\n\r\n其中，配置文件声明在工程的src目录下：【jdbc.properties】\r\n\r\n```properties\r\nuser=root\r\npassword=abc123\r\nurl=jdbc:mysql://localhost:3306/test\r\ndriverClass=com.mysql.jdbc.Driver\r\n```\r\n\r\n> 说明：使用配置文件的方式保存配置信息，在代码中加载配置文件\r\n>\r\n> **使用配置文件的好处：**\r\n>\r\n> ①实现了代码和数据的分离，如果需要修改配置信息，直接在配置文件中修改，不需要深入代码\r\n> ②如果修改了配置信息，省去重新编译的过程。', 'https://picsum.photos/id/119/810/540', '转载', '21', '0', '\0', '\0', '', '', '', '2021-04-27 22:39:01', '2021-04-30 14:59:32', '31', '1', '本文分两章，第一章为JDBC的描述，第二章为获取数据库的连接。笔记转载于atguigu的宋老师。');
INSERT INTO `t_blog` VALUES ('25', '冒泡排序的思想与代码实现', '1.基本介绍\r\n\r\n冒泡排序（Bubble Sorting）的基本思想是：通过对待排序序列从前向后（从下标较小的元素开始）,依次比较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就象水底下的气泡一样逐渐向上冒。\r\n\r\n\r\n算法可优化：\r\n因为排序的过程中，各元素不断接近自己的位置，如果一趟比较下来没有进行过交换，就说明序列有序，因此要在排序过程中设置一个标志 flag 判断元素是否进行过交换。从而减少不必要的比较。\r\n\r\n2.演示冒泡过程的例子\r\n\r\n小结上面的图解过程:\r\n(1)	一共进行 数组的大小-1 次大的循环；\r\n(2)	每一趟排序的次数在逐渐的减少；\r\n(3)	如果我们发现在某趟排序中，没有发生一次交换，可以提前结束冒泡排序。这个就是优化！！！\r\n\r\n\r\n3.冒泡排序应用实例\r\n\r\n我们举一个具体的案例来说明冒泡法。我们将五个无序的数：3, 9, -1, 10, -2  使用冒泡排序法将其排成一个从小到大的有序数列。\r\n\r\n4.代码实现:\r\n```java\r\npackage com.bo.sort;\r\n\r\n/**\r\n * 冒泡排序\r\n * 时间复杂度 T(n) = O(n^2)\r\n * @author Bo\r\n * @create 2021-05-13 20:47\r\n */\r\npublic class BubbleSort {\r\n    public static void main(String[] args) {\r\n//        int[] array = new int[]{3, 9, -1, 10, -2};\r\n        int[] array = new int[80000];\r\n        for (int i = 0; i < 80000; i++) {\r\n            array[i] = (int)(Math.random() * 800000);\r\n        }\r\n\r\n        long startTime = System.currentTimeMillis(); //获取开始时间\r\n\r\n        int[] bubbleArray = bubbleSort(array); //测试的代码段\r\n\r\n        long endTime = System.currentTimeMillis(); //获取结束时间\r\n\r\n        System.out.println(\"程序运行时间：\" + (endTime - startTime) + \"ms\"); //输出程序运行时间\r\n\r\n        for (int i : bubbleArray) {\r\n            System.out.print(i + \" \");\r\n        }\r\n    }\r\n\r\n\r\n    public static int[] bubbleSort(int[] array) {\r\n        //定义一个新的数组，用于存放排序后的数据\r\n        int[] arr = array;\r\n        //用于标记是否有某一趟排序中，有没有发生过交换的。\r\n        boolean swap = false;\r\n        //定义一个临时变量存储数据\r\n        int temp;\r\n        //外层循环，次数为数组长度-1次（第一次循环确定数组中最大的值，第二次确定次大值，以此类推）\r\n        for (int i = 0; i < arr.length - 1; i++) {\r\n            //内层循环，循环次数为数组长度-1-当前排序趟数\r\n            for (int j = 0; j < arr.length - 1 - i; j++) {\r\n                //从索引0开始，两两比较，值大的放在后面\r\n                if (arr[j] > arr[j+1]){\r\n                    temp = arr[j+1];\r\n                    arr[j+1] = arr[j];\r\n                    arr[j] = temp;\r\n                    //表示此次排序中，发生过交换；即此时排序还没有完成。\r\n                    swap = true;\r\n                }\r\n            }\r\n            if (!swap){\r\n                //表示此趟排序中，没有发生过一次交换的。即此时排序已经完成，可以提前结束了!\r\n                //跳出for循环\r\n                break;\r\n            }else {\r\n                //表示此趟排序中，发生过交换的。\r\n                //swap已被设为true，需要重新设置回false，用于下一趟排序的判断\r\n                swap = false;\r\n            }\r\n        }\r\n        return arr;\r\n\r\n    }\r\n}\r\n\r\n```\r\n', 'https://picsum.photos/id/121/810/540', '原创', '25', '0', '', '', '', '', '', '2021-04-29 15:29:35', '2021-05-14 17:27:30', '33', '1', '关于冒泡排序的思想与代码实现');

-- ----------------------------
-- Table structure for t_blog_tags
-- ----------------------------
DROP TABLE IF EXISTS `t_blog_tags`;
CREATE TABLE `t_blog_tags` (
  `blog_id` bigint(20) DEFAULT NULL,
  `tag_id` bigint(20) DEFAULT NULL,
  KEY `blog_id` (`blog_id`) USING BTREE,
  KEY `tag_id` (`tag_id`) USING BTREE,
  CONSTRAINT `t_blog_tags_ibfk_1` FOREIGN KEY (`blog_id`) REFERENCES `t_blog` (`id`),
  CONSTRAINT `t_blog_tags_ibfk_2` FOREIGN KEY (`tag_id`) REFERENCES `t_tag` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 ROW_FORMAT=COMPACT;

-- ----------------------------
-- Records of t_blog_tags
-- ----------------------------
INSERT INTO `t_blog_tags` VALUES ('18', '4');
INSERT INTO `t_blog_tags` VALUES ('20', '2');
INSERT INTO `t_blog_tags` VALUES ('12', '7');
INSERT INTO `t_blog_tags` VALUES ('12', '8');
INSERT INTO `t_blog_tags` VALUES ('20', '4');
INSERT INTO `t_blog_tags` VALUES ('23', '6');
INSERT INTO `t_blog_tags` VALUES ('23', '9');
INSERT INTO `t_blog_tags` VALUES ('23', '15');
INSERT INTO `t_blog_tags` VALUES ('23', '17');
INSERT INTO `t_blog_tags` VALUES ('24', '10');
INSERT INTO `t_blog_tags` VALUES ('24', '13');
INSERT INTO `t_blog_tags` VALUES ('1', '6');
INSERT INTO `t_blog_tags` VALUES ('1', '4');
INSERT INTO `t_blog_tags` VALUES ('1', '16');
INSERT INTO `t_blog_tags` VALUES ('1', '15');
INSERT INTO `t_blog_tags` VALUES ('3', '1');
INSERT INTO `t_blog_tags` VALUES ('6', '18');
INSERT INTO `t_blog_tags` VALUES ('25', '23');
INSERT INTO `t_blog_tags` VALUES ('25', '20');
INSERT INTO `t_blog_tags` VALUES ('25', '22');
INSERT INTO `t_blog_tags` VALUES ('16', '23');
INSERT INTO `t_blog_tags` VALUES ('16', '24');
INSERT INTO `t_blog_tags` VALUES ('16', '25');
INSERT INTO `t_blog_tags` VALUES ('16', '26');
INSERT INTO `t_blog_tags` VALUES ('16', '27');
INSERT INTO `t_blog_tags` VALUES ('22', '24');
INSERT INTO `t_blog_tags` VALUES ('22', '25');
INSERT INTO `t_blog_tags` VALUES ('22', '26');
INSERT INTO `t_blog_tags` VALUES ('22', '23');

-- ----------------------------
-- Table structure for t_comment
-- ----------------------------
DROP TABLE IF EXISTS `t_comment`;
CREATE TABLE `t_comment` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `nickname` varchar(255) DEFAULT NULL,
  `email` varchar(255) DEFAULT NULL,
  `content` varchar(255) DEFAULT NULL,
  `avatar` varchar(255) DEFAULT NULL,
  `create_time` datetime DEFAULT NULL,
  `blog_id` bigint(20) DEFAULT NULL,
  `parent_comment_id` bigint(20) DEFAULT NULL,
  `admin_comment` bit(1) DEFAULT NULL,
  `root_comment_id` bigint(20) DEFAULT NULL,
  `parent_comment_name` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  KEY `blog_id` (`blog_id`) USING BTREE,
  CONSTRAINT `t_comment_ibfk_1` FOREIGN KEY (`blog_id`) REFERENCES `t_blog` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=85 DEFAULT CHARSET=utf8 ROW_FORMAT=COMPACT;

-- ----------------------------
-- Records of t_comment
-- ----------------------------
INSERT INTO `t_comment` VALUES ('4', '小红', '444@qq.com', '我是根2', '/images/avatar.jpg', '2021-04-25 13:42:53', '6', '-1', '\0', '-1', '');
INSERT INTO `t_comment` VALUES ('75', '肖剑波', '2486@qq.com', '111111111', 'https://picsum.photos/id/1/100/100', '2021-04-13 15:42:28', '6', '-1', '', '-1', '肖剑波');
INSERT INTO `t_comment` VALUES ('79', '肖剑波', '2466@qq.com', '11111111111111', 'https://picsum.photos/id/1/100/100', '2021-04-21 15:42:52', '6', '75', '', '75', '肖剑波');
INSERT INTO `t_comment` VALUES ('80', '21', 'sdad@qq.com', '哈哈哈', '/images/avatar.jpg', '2021-04-29 14:24:43', '6', '-1', '\0', '-1', '');
INSERT INTO `t_comment` VALUES ('81', '12312', '2480662125@qq.com', '哈哈哈哈', '/images/avatar.jpg', '2021-04-29 14:26:15', '6', '79', '\0', '75', '肖剑波');
INSERT INTO `t_comment` VALUES ('82', 'safa', '2480662125@qq.com', 'ffaf', '/images/avatar.jpg', '2021-04-29 14:44:09', '6', '79', '\0', '75', '肖剑波');
INSERT INTO `t_comment` VALUES ('83', '肖剑波', '248066@qq.com', '66666', 'https://picsum.photos/id/1/100/100', '2021-04-29 15:28:03', '6', '79', '', '75', '肖剑波');
INSERT INTO `t_comment` VALUES ('84', '编程小白', '578763642@qq.com', '学到新知识了，多谢博主！！！', '/images/avatar.jpg', '2021-05-12 23:22:12', '3', '-1', '\0', '-1', '');

-- ----------------------------
-- Table structure for t_tag
-- ----------------------------
DROP TABLE IF EXISTS `t_tag`;
CREATE TABLE `t_tag` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=28 DEFAULT CHARSET=utf8 ROW_FORMAT=COMPACT;

-- ----------------------------
-- Records of t_tag
-- ----------------------------
INSERT INTO `t_tag` VALUES ('1', '数组');
INSERT INTO `t_tag` VALUES ('2', 'Mybatis');
INSERT INTO `t_tag` VALUES ('4', 'Spring');
INSERT INTO `t_tag` VALUES ('5', 'SpringMVC');
INSERT INTO `t_tag` VALUES ('6', 'SpringBoot');
INSERT INTO `t_tag` VALUES ('7', '随想');
INSERT INTO `t_tag` VALUES ('8', '感悟');
INSERT INTO `t_tag` VALUES ('9', 'JUnit5');
INSERT INTO `t_tag` VALUES ('10', 'MySQL');
INSERT INTO `t_tag` VALUES ('13', 'JDBC');
INSERT INTO `t_tag` VALUES ('15', '框架');
INSERT INTO `t_tag` VALUES ('16', '配置');
INSERT INTO `t_tag` VALUES ('17', '单元测试');
INSERT INTO `t_tag` VALUES ('18', '时间复杂度');
INSERT INTO `t_tag` VALUES ('19', '空间复杂度');
INSERT INTO `t_tag` VALUES ('20', '排序');
INSERT INTO `t_tag` VALUES ('21', '选择排序');
INSERT INTO `t_tag` VALUES ('22', '冒泡排序');
INSERT INTO `t_tag` VALUES ('23', 'Java');
INSERT INTO `t_tag` VALUES ('24', '二叉排序树');
INSERT INTO `t_tag` VALUES ('25', '树');
INSERT INTO `t_tag` VALUES ('26', '算法');
INSERT INTO `t_tag` VALUES ('27', '平衡二叉树');

-- ----------------------------
-- Table structure for t_type
-- ----------------------------
DROP TABLE IF EXISTS `t_type`;
CREATE TABLE `t_type` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=34 DEFAULT CHARSET=utf8 ROW_FORMAT=COMPACT;

-- ----------------------------
-- Records of t_type
-- ----------------------------
INSERT INTO `t_type` VALUES ('1', 'JVM虚拟机');
INSERT INTO `t_type` VALUES ('7', 'C#');
INSERT INTO `t_type` VALUES ('20', 'C语言');
INSERT INTO `t_type` VALUES ('26', 'JavaScript');
INSERT INTO `t_type` VALUES ('27', 'C++');
INSERT INTO `t_type` VALUES ('28', '散文');
INSERT INTO `t_type` VALUES ('31', 'JAVA');
INSERT INTO `t_type` VALUES ('32', '数据结构');
INSERT INTO `t_type` VALUES ('33', '算法');

-- ----------------------------
-- Table structure for t_user
-- ----------------------------
DROP TABLE IF EXISTS `t_user`;
CREATE TABLE `t_user` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `nickname` varchar(255) DEFAULT NULL,
  `username` varchar(255) DEFAULT NULL,
  `password` varchar(255) DEFAULT NULL,
  `email` varchar(255) DEFAULT NULL,
  `avatar` varchar(255) DEFAULT NULL,
  `type` int(11) DEFAULT NULL,
  `create_time` datetime DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8 ROW_FORMAT=COMPACT;

-- ----------------------------
-- Records of t_user
-- ----------------------------
INSERT INTO `t_user` VALUES ('1', '肖剑波', '13189801123', '499b862fb07ce3b152ea4041b3c87857', '2480662125@qq.com', 'https://picsum.photos/id/1/100/100', '1', '2021-04-17 11:12:41', '2021-04-17 10:55:56');
